# 比价模型 · 步骤② 数据源绑定（主数据集 + 辅助数据集 + 关系）

## Plaintext 草图（可读原型）

```
[页头]
比价模型 · 编辑   进度: ①基本信息 → ②数据源绑定 → ③对象与维度 → ④指标与基准 → ⑤显示属性 → ⑥预览校验
按钮：返回 | 保存 | 下一步

──────────────────────────────────────────────────────────────────────────────

[区块 A] 主数据集
- 主数据集*        [ 协议价数据集 ds_agreement_price ▼ ]
- 主数据集别名*    [ a ]
- 说明：主数据集定义“参与侧”。后续对象/维度优先从主数据集取字段。

──────────────────────────────────────────────────────────────────────────────

[区块 B] 辅助数据集（可添加多条）
表头： 辅助数据集名称 | 数据集ID | 别名 | 连接类型 | 关联条件（可分组） | 关联条件预览 | 操作
行示例：
- 市场行情数据集        ds_market         m    [LEFT JOIN ▼]   [ + 添加条件组 ]
   条件组1（AND）：
     [a.price  =  m.price]  [+ 添加条件]   [切换为 OR]
     [a.trade_date =  m.tx_date]
- 招采中标数据集        ds_bid            b    [LEFT JOIN ▼]   [a.brand = b.brand] …
- 历史采购数据集        ds_po_hist        h    [LEFT JOIN ▼]   组1(AND)：[a.vendor_id = h.vendor_id]
                                                                  组1(AND)：[a.brand = h.brand]

行尾： [校验] [删除]

行内交互：
- “添加条件组” → 新增一个分组（默认 AND 组，可切换为 OR 组）
- 条件 = 左表达式 [数据集别名.字段 ▼] + 运算符 [=, <>, >, <, BETWEEN, IN, LIKE…] + 右表达式 [别名.字段/常量]
- 右侧“关联条件预览”随选随显 SQL 片段，高亮别名与字段

表尾： [+ 添加辅助数据集]

──────────────────────────────────────────────────────────────────────────────

[区块 C] 条件继承（可选）
- 将主数据集的全局条件映射到指定辅助数据集（用于模型/方案里统一筛选）
- 时间映射：   a.trade_date  →  m.tx_date,  h.tx_date,  b.publish_date
- 组织映射：   a.org_id      →  m.org_id,   h.org_id
- 说明：仅建立映射关系，真正的筛选值来自“方案→执行范围/查询条件”

──────────────────────────────────────────────────────────────────────────────

[区块 D] 校验与提示
- [立即校验]  → 运行 3 类校验：
  1) 别名唯一性、数据集存在性、JOIN 循环/笛卡尔积风险
  2) 关联条件字段存在&类型兼容
  3) 对齐键覆盖度（下一步会用到）：所有辅助集是否至少包含对齐键字段
- 结果：✅ / ⚠️ 错误项明细（行内定位）
```

---

## UI 原型说明（关键交互）

* **数据集选择器**：选中后，字段选择器仅列出该数据集字段；支持搜索。
* **别名**：强制唯一，正则校验 `^[a-z][a-z0-9_]{0,2}$`（建议 1\~3 个字符，便于 SQL 可读）。
* **关联条件编辑器**：

  * 左/右表达式支持：`<别名.字段>`、常量（数字、字符串、日期）、函数（可选）。
  * 条件组支持**AND/OR**切换；预览自动加括号，防止逻辑歧义。
  * 运算符支持：`=、<>、>、>=、<、<=、BETWEEN、IN、LIKE、IS NULL、IS NOT NULL`。
* **JOIN 类型**：`LEFT / INNER / RIGHT / FULL`（默认 LEFT）。
* **校验**：

  * 行内“校验”只验证该行 JOIN 片段。
  * 页尾“立即校验”执行全量校验。
* **Condition Mapping（条件继承映射）**：

  * 仅保存“字段映射关系”，不带具体值。值在方案里下发到“主数据集字段”，引擎据此映射到辅助集字段。

---

## 界面配置 JSON（Schema + 示例）

### 1) Schema（约定）

```json
{
  "primary": {
    "datasetId": "string",
    "alias": "string"
  },
  "assists": [
    {
      "datasetId": "string",
      "alias": "string",
      "joinType": "LEFT|INNER|RIGHT|FULL",
      "conditionGroups": [
        {
          "logic": "AND|OR",
          "conditions": [
            {
              "left":  { "ds": "alias", "field": "string" },
              "op":    "EQ|NE|GT|GE|LT|LE|BETWEEN|IN|LIKE|IS_NULL|NOT_NULL",
              "right": { "type": "field|const|list|range",
                         "value": "string|number|boolean|null|array|{from:...,to:...}",
                         "ds": "alias(optional)"
              }
            }
          ]
        }
      ]
    }
  ],
  "conditionMapping": {
    "time": {
      "from": { "ds": "a", "field": "trade_date" },
      "to":   [{ "ds": "m", "field": "tx_date" }, { "ds": "h", "field": "tx_date" }, { "ds": "b", "field": "publish_date" }]
    },
    "org": {
      "from": { "ds": "a", "field": "org_id" },
      "to":   [{ "ds": "m", "field": "org_id" }, { "ds": "h", "field": "org_id" }]
    }
  }
}
```

**说明**

* `conditionGroups` 即 UI 的“条件组”，`logic` 表示组内条件的连接方式；多组之间默认为 AND 连接（如需全自定义，可再加 `groupRelation`）。
* `right.type`:

  * `field`：右侧为字段（需填 `ds`、`field`）
  * `const`：常量（数值/字符串/日期）
  * `list`：IN 列表
  * `range`：BETWEEN 区间（`{from,to}`）
* 条件继承映射**只保存映射关系**，不存具体值；值在方案执行时绑定到 `conditionMapping.time.from` 等“from 字段”，引擎再自动映射到 `to` 列表。

---

### 2) 示例（与你截图一致）

```json
{
  "primary": {
    "datasetId": "ds_agreement_price",
    "alias": "a"
  },
  "assists": [
    {
      "datasetId": "ds_market",
      "alias": "m",
      "joinType": "LEFT",
      "conditionGroups": [
        {
          "logic": "AND",
          "conditions": [
            { "left": { "ds": "a", "field": "price" }, "op": "EQ", "right": { "type": "field", "ds": "m", "field": "price" } },
            { "left": { "ds": "a", "field": "trade_date" }, "op": "EQ", "right": { "type": "field", "ds": "m", "field": "tx_date" } }
          ]
        }
      ]
    },
    {
      "datasetId": "ds_bid",
      "alias": "b",
      "joinType": "LEFT",
      "conditionGroups": [
        {
          "logic": "AND",
          "conditions": [
            { "left": { "ds": "a", "field": "brand" }, "op": "EQ", "right": { "type": "field", "ds": "b", "field": "brand" } }
          ]
        }
      ]
    },
    {
      "datasetId": "ds_po_hist",
      "alias": "h",
      "joinType": "LEFT",
      "conditionGroups": [
        {
          "logic": "AND",
          "conditions": [
            { "left": { "ds": "a", "field": "vendor_id" }, "op": "EQ", "right": { "type": "field", "ds": "h", "field": "vendor_id" } },
            { "left": { "ds": "a", "field": "brand" }, "op": "EQ", "right": { "type": "field", "ds": "h", "field": "brand" } }
          ]
        }
      ]
    }
  ],
  "conditionMapping": {
    "time": {
      "from": { "ds": "a", "field": "trade_date" },
      "to": [
        { "ds": "m", "field": "tx_date" },
        { "ds": "h", "field": "tx_date" },
        { "ds": "b", "field": "publish_date" }
      ]
    },
    "org": {
      "from": { "ds": "a", "field": "org_id" },
      "to": [
        { "ds": "m", "field": "org_id" },
        { "ds": "h", "field": "org_id" }
      ]
    }
  }
}
```

---

## 校验规则（开发必看）

1. **别名唯一**：`primary.alias` 与所有 `assists[].alias` 不得重复；命名长度 1–3，`[a-z][a-z0-9_]*`。
2. **JOIN 完整**：每个 `assists[i]` 至少 1 个条件；字段需存在于各自数据集。
3. **条件组逻辑**：同组内按 `logic` 连接，不同组默认 AND（可配置）。`BETWEEN/IN` 需 `range/list` 值。
4. **循环/笛卡尔积**：引擎给出风险提示（如没有任何等值条件）。
5. **条件继承映射**：`from` / `to` 字段存在；方案层如果给了时间/组织条件则按映射注入。
6. **SQL 预览**：基于上述 JSON 生成 FROM/JOIN 片段，预览展示。

---

## 生成 SQL（参考伪码）

```sql
FROM ds_agreement_price a
LEFT JOIN ds_market m
  ON a.price = m.price
 AND a.trade_date = m.tx_date
LEFT JOIN ds_bid b
  ON a.brand = b.brand
LEFT JOIN ds_po_hist h
  ON a.vendor_id = h.vendor_id
 AND a.brand = h.brand
/* 方案层 WHERE（若启用条件继承）
   where a.trade_date BETWEEN :start AND :end
   and a.org_id in (:orgs)
   → 自动注入：
     and m.tx_date BETWEEN :start AND :end
     and h.tx_date BETWEEN :start AND :end
     and b.publish_date BETWEEN :start AND :end
     and m.org_id in (:orgs)
     and h.org_id in (:orgs)
*/
```

---
